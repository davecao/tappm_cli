#!/usr/bin/env python
# This script was automatically generated by distutils2
# import codecs
import sys
import os
import io

import distutils.sysconfig as dsc

# from distutils.core import setup, Extension
from distutils.sysconfig import get_config_var
from setuptools import setup

from glob import glob
pj = os.path.join

# from distutils.command.install_data import install_data

try:
    from ConfigParser import RawConfigParser
except ImportError:
    from configparser import RawConfigParser

pyincdir = dsc.get_python_inc(plat_specific=1)
pylibdir = os.path.join('/', *pyincdir.split('/')[:-2] + ['lib'])

try:
    import numpy as np
    np_include_dir = np.get_include()
except ImportError:
    np_include_dir = os.path.join(
                pylibdir.replace('lib/python', 'local/lib/python'),
                'numpy', 'core', 'include')
    print("Unable to import numpy, trying header \n{}".format(
            np_include_dir))
    # raise ImportError('Numpy is a required package')


def split_multiline(value):
    """Split a multiline string into a list, excluding blank lines."""
    val = value.encode('utf-8')
    return [element for element in
            (line.strip() for line in val.split('\n'))
            if element]


def cfg_to_args(path='setup.cfg'):
    """Compatibility helper to use setup.cfg in setup.py.

    This functions uses an existing setup.cfg to generate a dictionnary of
    keywords that can be used by distutils.core.setup(**kwargs).  It is used
    by generate_setup_py.

    *file* is the path to the setup.cfg file.  If it doesn't exist,
    PackagingFileError is raised.
    """

    # XXX ** == needs testing
    D1_D2_SETUP_ARGS = {"name": ("metadata",),
                        "version": ("metadata",),
                        "author": ("metadata",),
                        "author_email": ("metadata",),
                        "maintainer": ("metadata",),
                        "maintainer_email": ("metadata",),
                        "url": ("metadata", "home_page"),
                        "description": ("metadata", "summary"),
                        "long_description": ("metadata", "description"),
                        "download-url": ("metadata",),
                        "classifiers": ("metadata", "classifier"),
                        "platforms": ("metadata", "platform"),  # **
                        "license": ("metadata",),
                        "requires": ("metadata", "requires_dist"),
                        "provides": ("metadata", "provides_dist"),  # **
                        "obsoletes": ("metadata", "obsoletes_dist"),  # **
                        "package_dir": ("files", 'packages_root'),
                        "packages": ("files",),
                        "scripts": ("files",),
                        "resources": ("files",),
                        "py_modules": ("files", "modules"),  # **
                        "package_data": ("files", "package_data"),
                        }

    MULTI_FIELDS = ("classifiers",
                    "platforms",
                    "requires",
                    "provides",
                    "obsoletes",
                    "packages",
                    "scripts",
                    "py_modules",
                    "extension",
                    "resources",
                    "package_data"
                    )

    def has_get_option(config, section, option):
        if config.has_option(section, option):
            return config.get(section, option)
        elif config.has_option(section, option.replace('_', '-')):
            return config.get(section, option.replace('_', '-'))
        else:
            return False

    # The real code starts here
    config = RawConfigParser()
    # f = codecs.open(path, encoding='utf-8')
    f = io.open(path, encoding="utf-8")
    try:
        config.readfp(f)
    finally:
        f.close()

    kwargs = {}
    for arg in D1_D2_SETUP_ARGS:
        if len(D1_D2_SETUP_ARGS[arg]) == 2:
            # The distutils field name is different than distutils2's
            section, option = D1_D2_SETUP_ARGS[arg]

        else:
            # The distutils field name is the same thant distutils2's
            section = D1_D2_SETUP_ARGS[arg][0]
            option = arg

        in_cfg_value = has_get_option(config, section, option)
        if not in_cfg_value:
            # There is no such option in the setup.cfg
            if arg == 'long_description':
                filenames = has_get_option(config, section, 'description-file')
                if filenames:
                    filenames = split_multiline(filenames)
                    in_cfg_value = []
                    for filename in filenames:
                        # fp = codecs.open(filename, encoding='utf-8')
                        fp = io.open(filename, encoding="utf-8")
                        try:
                            in_cfg_value.append(fp.read())
                        finally:
                            fp.close()
                    in_cfg_value = '\n\n'.join(in_cfg_value)
            else:
                continue

        if arg == 'package_dir' and in_cfg_value:
            in_cfg_value = {'': in_cfg_value}

        if arg in MULTI_FIELDS:
            # support multiline options
            in_cfg_value = split_multiline(in_cfg_value)
            if arg == 'packages' and in_cfg_value:
                if 'package_dir' in kwargs:
                    if kwargs['package_dir']['']:
                        in_cfg_value = [
                            kwargs['package_dir']['']+'.'+pack
                            for pack in in_cfg_value]
            if arg == 'package_data' and in_cfg_value:
                datafiles = {}
                for line in in_cfg_value:
                    split_path = line.split('/')
                    package_struct_str = ".".join(split_path[:-1]).strip()
                    files = [f.split('/')[-1] for f in glob(line)]
                    if package_struct_str in datafiles:
                        datafiles[package_struct_str].extend(files)
                    else:
                        datafiles[package_struct_str] = files
                    # datafiles[package_struct_str] = files
                in_cfg_value = datafiles
                kwargs['install_package_data'] = True
            if arg == 'resources' and in_cfg_value:
                data_files = []
                for line in in_cfg_value:
                    file_str = line.split('=')[0].strip()
                    files = glob(file_str)
                    dfile = ""
                    if os.path.dirname(files[0]):
                        dfile = os.path.dirname(files[0])
                    data_files.append(
                        ('share'+os.sep+'tappm'+os.sep+dfile,
                         files))
                kwargs['data_files'] = data_files
        kwargs[arg] = in_cfg_value
    return kwargs

# setup
general_settings = cfg_to_args()
# Key: resources has to be removed
general_settings['zip-safe'] = False
general_settings.pop('resources')
general_settings['install_requires'] = [
    'jinja2>2.6',
    'numpy>1.9.0']
setup(**general_settings)
# setup(**cfg_to_args())
